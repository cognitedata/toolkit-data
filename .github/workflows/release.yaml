name: Zip, Checksum, and Update README on Main Merge

on:
  push:
    branches:
      - librarian
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    outputs:
      zip_name: ${{ steps.file_names.outputs.zip_name }}
      checksum: ${{ steps.checksum.outputs.sha256_hash }}

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Generate a dynamic zip file name
        id: file_names
        run: |
          ZIP_NAME=$(echo "modules" | tr '/' '-')
          echo "zip_name=${ZIP_NAME}.zip" >> $GITHUB_OUTPUT

      - name: Create Zip File
        run: zip -r ${{ steps.file_names.outputs.zip_name }} modules/

      - name: Generate SHA256 Checksum
        id: checksum
        run: |
          checksum_value=$(sha256sum ${{ steps.file_names.outputs.zip_name }} | awk '{ print $1 }')
          echo "sha256_hash=${checksum_value}" >> $GITHUB_OUTPUT

      - name: Upload Zip as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.file_names.outputs.zip_name }}
          path: ${{ steps.file_names.outputs.zip_name }}

      - name: Save checksum and filename for README job
        # This creates a file containing the metadata for the update-readme job
        run: |
          echo "${{ steps.file_names.outputs.zip_name }},sha256:${{ steps.checksum.outputs.sha256_hash }}" >> checksum_data.txt

      - name: Upload metadata for README job
        # This artifact is temporary and will be used by the next job
        uses: actions/upload-artifact@v4
        with:
          name: metadata-modules
          path: checksum_data.txt

  create-release:
    # This job runs only after the build job has succeeded
    needs: build
    runs-on: ubuntu-latest

    # Grant permissions for the action to create releases
    permissions:
      contents: write

    steps:
      - name: Download zip artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build.outputs.zip_name }}

      - name: Download metadata artifact
        uses: actions/download-artifact@v4
        with:
          name: metadata-modules

      - name: Check out repository for packages.toml
        uses: actions/checkout@v4

      - name: Generate packages list
        id: packages_list
        run: |
          # Use awk to parse packages.toml and extract package information
          PACKAGES_CONTENT=$(awk '
            /^\[packages\./ {
              # Extract package name from [packages.name]
              gsub(/^\[packages\./, "", $0)
              gsub(/\]$/, "", $0)
              package_name = $0
              title = ""
              description = ""
              next
            }
            /^title\s*=\s*"/ {
              # Extract title
              gsub(/^title\s*=\s*"/, "", $0)
              gsub(/"$/, "", $0)
              title = $0
            }
            /^description\s*=\s*"/ {
              # Extract description
              gsub(/^description\s*=\s*"/, "", $0)
              gsub(/"$/, "", $0)
              description = $0
              # Print the complete package info when we have all fields
              if (package_name && title && description) {
                printf "- **%s**: %s - %s\n", package_name, title, description
              }
            }
          ' modules/packages.toml)
          
          echo "content<<EOF" >> $GITHUB_OUTPUT
          echo "$PACKAGES_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate release tag
        id: tag
        run: |
          # Get the latest release tag to determine the next patch version
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          
          # Extract the version numbers
          if [[ $LATEST_TAG =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
            MAJOR=${BASH_REMATCH[1]}
            MINOR=${BASH_REMATCH[2]}
            PATCH=${BASH_REMATCH[3]}
          else
            # Default to 1.0.0 if no valid tag found
            MAJOR=1
            MINOR=0
            PATCH=0
          fi
          
          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_TAG="v${MAJOR}.${MINOR}.${NEW_PATCH}"
          
          echo "tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Generated tag: $NEW_TAG"

      - name: Generate release body
        id: release_body
        run: |
          cat > release_body.md << EOF
          ## Usage:
          
          \`\`\`cdf.toml
          
          [libraries.toolkit-data]
          url = "https://github.com/${{ github.repository }}/releases/download/${{ steps.tag.outputs.tag }}/${{ needs.build.outputs.zip_name }}"
          sha256 = "sha256:${{ needs.build.outputs.checksum }}"
          \`\`\`
          
          ## Content:
          
          This release contains the following packages:
          
          ${{ steps.packages_list.outputs.content }}
          EOF
          
          echo "body<<EOF" >> $GITHUB_OUTPUT
          cat release_body.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          release_name: "${{ steps.tag.outputs.tag }}"
          body: ${{ steps.release_body.outputs.body }}
          draft: false
          prerelease: false

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: ./${{ needs.build.outputs.zip_name }}
          asset_name: ${{ needs.build.outputs.zip_name }}
          asset_content_type: application/zip